import pandas as pd 
import numpy as np
import os
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report

# replace with your folder's path
folder_path = os.getcwd()

all_files = os.listdir(folder_path)

testdf = pd.read_csv("2024Combine.csv")
print(testdf.head())
testqb = testdf[testdf['Pos'] == 'QB'].reset_index(drop=True)
test = testqb.iloc[:, 7:12]
test.drop(columns=['Bench'], inplace=True)
test.fillna(test.mean(), inplace=True)

# Filter out non-CSV files
csv_files = [f for f in all_files if f.endswith('.csv') and f != "combined_file.csv" and f != "2024Combine.csv"]

# Create a list to hold the dataframes
df_list = []

for csv in csv_files:
    file_path = os.path.join(folder_path, csv)
    try:
        # Try reading the file using default UTF-8 encoding
        df = pd.read_csv(file_path)
        df_list.append(df)
    except UnicodeDecodeError:
        try:
            # If UTF-8 fails, try reading the file using UTF-16 encoding with tab separator
            df = pd.read_csv(file_path, sep='\t', encoding='utf-16')
            df_list.append(df)
        except Exception as e:
            print(f"Could not read file {csv} because of error: {e}")
    except Exception as e:
        print(f"Could not read file {csv} because of error: {e}")

# Concatenate all data into one DataFrame
combdata = pd.concat(df_list, ignore_index=True)

# Save the final result to a new CSV file
combdata.to_csv(os.path.join(folder_path, 'combined_file.csv'), index=False)

#df = pd.DataFrame(combdata)

dfqb = combdata[combdata['Pos'] == 'QB'].reset_index(drop=True)
dfqb.insert(13,"Success",0)



proQB = ["Patrick Mahomes", "Deshaun Watson", "Baker Mayfield", "Josh Allen", "Lamar Jackson", "Kyler Murray", "Joe Burrow", "Tua Tagovailoa", "Justin Herbert", "Jordan Love", "Jalen Hurts", "Trevor Lawrence","Brock Purdy", "C.J. Stroud", "Anthony Richardson"]
proWR = []
#row_list= []

dfProQB = pd.DataFrame(columns=dfqb.columns)

for QB in proQB:
# Iterate through each row of the original DataFrame
    row_index = dfqb[dfqb["Player"] == QB].index[0]

    dfqb.iloc[row_index, 13] = 1

dfqb.drop(columns=['Bench'], inplace=True)
#dfProQB = dfqb.iloc[row_list]
#dfProQB.insert(14,"Success")
X = dfqb.iloc[:, 7:11]  # Extract columns 7 through 12 as features
y = dfqb.iloc[:, 12]    # Extract column 13 as the target variable

X.fillna(X.mean(), inplace=True) #Handle NaN values

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Standardize the features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Choose a classification model (e.g., logistic regression)
model = LogisticRegression()

# Train the model
model.fit(X_train_scaled, y_train)

# Evaluate the model
y_pred = model.predict(X_test_scaled)
print(classification_report(y_test, y_pred))

# Predict success labels for new data
# Assuming new_data is a DataFrame with the same columns as X (columns 2 through 5)
new_data_scaled = scaler.transform(test)
prediction_labels = model.predict(new_data_scaled)

# Assuming new_data is your original DataFrame for new data
# Add the predicted labels to the DataFrame
test['Predicted_Success'] = prediction_labels

print(prediction_labels)

# Filter the DataFrame to show only candidates predicted to have "success"
predicted_success_candidates = test[test['Predicted_Success'] == 1]

# Display the predicted successful candidates
print(predicted_success_candidates)